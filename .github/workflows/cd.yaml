name: Terraform & Docker Deploy (CD)

on:
  workflow_run:
    workflows: ["Terraform CI (Non-Mutating)"]
    types:
      - completed

concurrency:
  group: cd-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.ARN_GITHUB_ACTIONS_ROLE }}
          role-session-name: GitHubActionsSession
          aws-region: ${{ secrets.TF_VAR_REGION }}

      - name: Check Terraform backend existence
        id: backend_check
        run: |
          set -euo pipefail
          REGION="${{ secrets.TF_VAR_REGION }}"
          BUCKET="${{ secrets.TF_STATE_BACKEND_BUCKET_NAME }}"
          TABLE="${{ secrets.TF_STATE_LOCK_TABLE }}"
          echo "Checking for S3 bucket: $BUCKET"
          if aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            bucket_ok=1
          else
            bucket_ok=0
          fi
          echo "Checking for DynamoDB table: $TABLE"
          if aws dynamodb describe-table --table-name "$TABLE" >/dev/null 2>&1; then
            table_ok=1
          else
            table_ok=0
          fi
          if [ $bucket_ok -eq 1 ] && [ $table_ok -eq 1 ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Backend already provisioned."
          elif [ $bucket_ok -eq 0 ] && [ $table_ok -eq 0 ]; then
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Backend does not exist (fresh provisioning required)."
          else
            echo "exists=partial" >> $GITHUB_OUTPUT
            echo "Inconsistent state: one resource exists and the other does not."
            exit 1
          fi

      - name: Generate backend.tf (existing backend)
        if: steps.backend_check.outputs.exists == 'true'
        run: |
          WORK_DIR=aws_infra/enviroments/dev
          mkdir -p "$WORK_DIR"
          cat > "$WORK_DIR/backend.tf" <<EOF
          terraform {
            backend "s3" {
              bucket         = "${{ secrets.TF_STATE_BACKEND_BUCKET_NAME }}"
              key            = "terraform_state/statefile.tfstate"
              region         = "${{ secrets.TF_VAR_REGION }}"
              encrypt        = true
              dynamodb_table = "${{ secrets.TF_STATE_LOCK_TABLE }}"
            }
          }
          EOF
          echo "Generated backend.tf (reused existing backend)."

      - name: Bootstrap backend and generate backend.tf
        if: steps.backend_check.outputs.exists == 'false'
        run: |
          BOOTSTRAP_DIR=aws_infra/bootstrap
          WORK_DIR=aws_infra/enviroments/dev
          REGION="${{ secrets.TF_VAR_REGION }}"
          echo "Bootstrapping remote backend resources..."
          terraform -chdir=$BOOTSTRAP_DIR init -input=false
          terraform -chdir=$BOOTSTRAP_DIR apply -auto-approve -input=false -var="aws_region=${REGION}"
          STATE_BUCKET=$(terraform -chdir=$BOOTSTRAP_DIR output -raw tf_state_bucket_name)
          LOCK_TABLE=$(terraform -chdir=$BOOTSTRAP_DIR output -raw tf_state_lock_table)
          mkdir -p "$WORK_DIR"
          cat > "$WORK_DIR/backend.tf" <<EOF
          terraform {
            backend "s3" {
              bucket         = "${STATE_BUCKET}"
              key            = "terraform_state/statefile.tfstate"
              region         = "${REGION}"
              encrypt        = true
              dynamodb_table = "${LOCK_TABLE}"
            }
          }
          EOF
          echo "Generated backend.tf from freshly bootstrapped resources."

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Initialize Terraform
        run: terraform init
        working-directory: aws_infra/enviroments/dev

      - name: Validate Terraform configuration
        run: terraform validate
        working-directory: aws_infra/enviroments/dev

      - name: Set Terraform variables
        run: |
          echo "TF_VAR_allowed_ssh_ip=${{ secrets.TF_VAR_ALLOWED_SSH_IP }}" >> $GITHUB_ENV
          echo "TF_VAR_key_name=${{ secrets.TF_VAR_SSH_KEY_NAME }}" >> $GITHUB_ENV
          echo "TF_VAR_db_user=${{ secrets.TF_VAR_DB_USER }}" >> $GITHUB_ENV
          echo "TF_VAR_db_password=${{ secrets.TF_VAR_DB_PASSWORD }}" >> $GITHUB_ENV
          echo "TF_VAR_db_name=${{ secrets.TF_VAR_DB_NAME }}" >> $GITHUB_ENV
          echo "TF_VAR_region=${{ secrets.TF_VAR_REGION }}" >> $GITHUB_ENV
          echo "TF_VAR_bucket_name=${{ secrets.TF_VAR_BUCKET_NAME }}" >> $GITHUB_ENV

      - name: Debug Terraform variables
        run: env | grep TF_VAR_

      - name: Apply Terraform (Phase 1)
        run: |
          terraform apply -auto-approve \
            -target=module.ecr \
            -target=module.vpc \
            -target=module.security \
            -target=module.alb \
            -target=module.rds \
            -target=module.s3 \
            -target=module.iam \
            -target=module.lambda \
            -target=module.monitoring \
            -target=module.step_functions \
            -target=module.event_bridge \
            || exit 1
        working-directory: aws_infra/enviroments/dev

      - name: Retrieve Terraform outputs
        run: |
          echo "Fetching Terraform outputs..."
          POSTGRES_HOST=$(terraform output -raw rds_host)
          ECR_REPOSITORY_URL=$(terraform output -raw ecr_repository_url)
          ALB_DNS_NAME=$(terraform output -raw alb_dns_name)
          ECR_REGISTRY_URL=${ECR_REPOSITORY_URL%%/*}
          echo "POSTGRES_HOST=$POSTGRES_HOST" >> $GITHUB_ENV
          echo "ECR_REPOSITORY_URL=$ECR_REPOSITORY_URL" >> $GITHUB_ENV
          echo "ECR_REGISTRY_URL=$ECR_REGISTRY_URL" >> $GITHUB_ENV
          echo "ALB_DNS_NAME=$ALB_DNS_NAME" >> $GITHUB_ENV
          echo "POSTGRES_HOST: $POSTGRES_HOST"
          echo "ECR_REPOSITORY_URL: $ECR_REPOSITORY_URL"
          echo "ECR_REGISTRY_URL: $ECR_REGISTRY_URL"
          echo "ALB_DNS_NAME: $ALB_DNS_NAME"
        working-directory: aws_infra/enviroments/dev

      - name: Set image tag
        run: |
          # Use short SHA for tagging; customize if you need semantic versioning
          IMAGE_TAG=${GITHUB_SHA::7}
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          # Propagate to Terraform so ASG/user data can pull matching versioned tags
          echo "TF_VAR_image_tag=$IMAGE_TAG" >> $GITHUB_ENV
          echo "Using IMAGE_TAG=$IMAGE_TAG"

      - name: Generate .env file for backend
        run: |
          set -euo pipefail
          mkdir -p backend
          # Ensure restrictive permissions (600) via temporary umask
          ( umask 177; : > backend/.env )
          {
            echo "JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}"
            echo "POSTGRES_USER=${{ secrets.TF_VAR_DB_USER }}"
            echo "POSTGRES_PASSWORD=${{ secrets.TF_VAR_DB_PASSWORD }}"
            echo "POSTGRES_DB=${{ secrets.TF_VAR_DB_NAME }}"
            echo "POSTGRES_HOST=${{ env.POSTGRES_HOST }}"
            echo "POSTGRES_URI=postgresql://${{ secrets.TF_VAR_DB_USER }}:${{ secrets.TF_VAR_DB_PASSWORD }}@${{ env.POSTGRES_HOST }}:5432/${{ secrets.TF_VAR_DB_NAME }}"
            echo "S3_BUCKET_NAME=${{ secrets.TF_VAR_BUCKET_NAME }}"
            echo "S3_REGION=${{ secrets.TF_VAR_REGION }}"
            echo "USE_S3_STORAGE=true"
          } >> backend/.env
          chmod 600 backend/.env
          # Mask sensitive values so accidental echoes won't expose them
          echo '::add-mask::'${{ secrets.TF_VAR_DB_PASSWORD }}
          echo '::add-mask::'${{ secrets.JWT_SECRET_KEY }}
          URI_LINE=$(grep '^POSTGRES_URI=' backend/.env | cut -d= -f2- || true)
          [ -n "$URI_LINE" ] && echo "::add-mask::$URI_LINE"
          echo ".env file created (contents not printed)."

      - name: Build Docker image
        run: |
          cd backend
          docker build -t app-backend:build . || exit 1

      - name: Tag and push Docker image to ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.TF_VAR_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY_URL }}
          # Tag backend image with prefix inside single repository
          docker tag app-backend:build ${{ env.ECR_REPOSITORY_URL }}:backend-${{ env.IMAGE_TAG }}
          docker tag app-backend:build ${{ env.ECR_REPOSITORY_URL }}:backend-latest
          docker push ${{ env.ECR_REPOSITORY_URL }}:backend-${{ env.IMAGE_TAG }} || exit 1
          docker push ${{ env.ECR_REPOSITORY_URL }}:backend-latest || exit 1

      - name: Prepare frontend build env
        run: |
          echo "REACT_APP_BACKEND_SERVER=http://${{ env.ALB_DNS_NAME }}" > frontend/.env
          chmod 600 frontend/.env
          echo "Frontend .env prepared (not printed)."

      - name: Build frontend image
        run: |
          docker build -t app-frontend:build --build-arg REACT_APP_BACKEND_SERVER=http://${{ env.ALB_DNS_NAME }} frontend || exit 1

      - name: Tag and push frontend image
        run: |
          aws ecr get-login-password --region ${{ secrets.TF_VAR_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY_URL }}
          docker tag app-frontend:build ${{ env.ECR_REPOSITORY_URL }}:frontend-${{ env.IMAGE_TAG }}
          docker tag app-frontend:build ${{ env.ECR_REPOSITORY_URL }}:frontend-latest
          docker push ${{ env.ECR_REPOSITORY_URL }}:frontend-${{ env.IMAGE_TAG }} || exit 1
          docker push ${{ env.ECR_REPOSITORY_URL }}:frontend-latest || exit 1

      - name: Upload SQLite dump file to S3
        run: |
          aws s3 cp backend/app/sqlite_dump_clean.sql s3://${{ secrets.TF_VAR_BUCKET_NAME }}/db_backups/sqlite_dump_clean.sql

      - name: Apply Terraform (Phase 2)
        run: |
          terraform apply -auto-approve || exit 1
        working-directory: aws_infra/enviroments/dev

      - name: Cleanup .env (always)
        if: always()
        run: |
          if [ -f backend/.env ]; then
            # Attempt secure deletion; fallback to simple remove
            shred -u backend/.env 2>/dev/null || rm -f backend/.env
            echo ".env removed"
          else
            echo ".env already absent"
          fi

      - name: Clean up Docker images
        run: |
          docker rmi app-backend:build || true
          docker rmi app-frontend:build || true
          docker rmi ${{ env.ECR_REPOSITORY_URL }}:backend-${{ env.IMAGE_TAG }} || true
          docker rmi ${{ env.ECR_REPOSITORY_URL }}:frontend-${{ env.IMAGE_TAG }} || true
          docker rmi ${{ env.ECR_REPOSITORY_URL }}:backend-latest || true
          docker rmi ${{ env.ECR_REPOSITORY_URL }}:frontend-latest || true
